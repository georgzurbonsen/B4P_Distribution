

/*
	Utility Library.b4Ã¼
	____________________________________________________________________________________________________________


	A collection of useful functions

	____________________________________________________________________________________________________________


	Version 1.00		Runs on Beyond4P Release 4.12 or higher.

	Author:			Georg zur Bonsen
				Copyright (C) 2020 by Georg zur Bonsen, All Rights Reserved

	Contents:


	If you want to use this library, then you need to specify following function call:   include ( Utility Library )
	If the library is not in the same directory, then specfiy an appropriate directory path.


	Revision History:
	____________________________________________________________________________________________________________

	Library	Beyond4P	Date		Features

	1.00	5.00				First Release, supports HTML and EXCEL XML file formats from databases
	1.01	5.07		01.04.2019	Added: choose recent file
	1.02	5.08		10.06.2019	

*/


once
{

	//
	// Version verification
	// _________________________________________________________________________________________________________
	//

	global() version info utility library[] = "1.01";

	echo(new line + "Included 'Utility Library.txt' Release ", version info utility library[] );
	echo("Copyright (C) 2012..2020 Georg zur Bonsen, all rights reserved." + new line);

	

	if (numeral( left( version info[], ' ')) < 5.08)
	{
	    echo("Version Mismatch. Prerequisite for using this file 'Utility Library.txt' is Beyond4P Release 5.08 or newer");
	    echo("Please obtain and install latest available release.");
	    stop;
	}
	



	//
	// Advanced file functions
	// _________________________________________________________________________________________________________
	//



	// Function:	choose recent file
	//
	// Description:	Shows up to 35 file names and allows to choose from.
	//
	// Parameters:	prompt		Prompt text 
	//		path		Directory path to location where files are existing
	//		match		Matching pattern, e.g. "*.txt" (Microsoft specifc patterns)
	//		order		Sorting order, one of following:
	//				  oldest	List n oldest files
	//				  newest	List n newest files
	//				  first		List first n files (alphabetic order, start with A)
	//				  last		List last n files (reverse alphabetic order)
	//				  biggest	List n biggest files
	//				  smallest	List n smallest files
	//		count		Number of filesto show.  Must be between 1 and 35.
	//
	// Return val:	literal		Name of chosen file.



	define function ( choose recent file, { { prompt, literal }, { path, literal }, { match, literal }, { order, literal }, { count, numeral } } )
	{

	    if (order[] <> newest,oldest,first,last,biggest,smallest)
	    {
		exception( stop, compose("4th paramter: order = '", order[], "' is invalid,", new line, "Valid choises are: newest, oldest, first, last, biggest, smallest"), 1);
	    }

	    if ((count[] < 0) | (count[]>35))
	    {
		exception( stop, compose("5th paramter: count = '", count[], "' is invalid. Must be between 1..35"), 1);
		stop;
	    }

	    
	    ret val[] = directory listing( local directory table, path[], "*.*", files );
	    if (ret val[] < 0)
	    {
		exception( stop, compose("2nd paramter: path '", path[], "' not found."), 1);
	    }

	    ret val[] = directory listing( local directory table, path[], match[], files );
	    ret val[] = max( ret val[], 0 );

	    if (ret val[] = 0)
	    {
		echo("No files have been found" );
		return( "" ); // Nothing found
	    }

	    switch( order[] )
	    {
		case (newest)	table sort rows( local directory table, {Date Updated,Time Updated}, alphabetic down );
		case (oldest)	table sort rows( local directory table, {Date Updated,Time Updated}, alphabetic      );
		case (first)	table sort rows( local directory table, {Name}, alphabetic );
		case (last)	table sort rows( local directory table, {Name}, alphabetic down     );
		case (biggest)	table sort rows( local directory table, {Size}, numeric down );
		case (smallest)	table sort rows( local directory table, {Size}, numeric      );
	    }

	    if (count[] == 1) // Looking for only 1 file.  No menu query needed.
	    {
		return( [local directory table: Name, 1] );
	    }

	    echo("Found ", ret val[], " files.");
	    table delete remaining rows( local directory table, count[]+1 );

	    sequence[] = { '1'..'9','A'..'Z' }; // 35 elements
	    i[] = 0;
	    table insert columns( local directory table, {Menu Choice,Name with Date}, "", 0 );

	    table process( local directory table, [Menu Choice] = sequence[]{i[]++}; 
		[Name with Date] = literal([Name],"########################################") + "  ("+[Date Updated]+" "+[Time Updated]+"  "+literal([Size]/1024,"????0") + " kB)" );

	    echo(new line, prompt[]);
	    choice[] = table menu quick( local directory table, Menu Choice, Name with Date, Name );
	    
	    table delete( local directory table );
	    return(choice[]);
	}


//
// Following functions are experimental and not yet formally documented.
//
//
	define procedure( table load and keep, { { table name, literal }, { file name,  literal }, { columns to keep, parameters} } )
	{
	    echo("Loading table ", table name[], " from file ", file name[] );

	    if (function name[]= table load csv and keep)
	    {
		table load( table name[], file name[] );
	    }
	    else
	    {
		table load( table name[], file name[], MHTML );
	    }
	    table delete blank rows( table name[] );
	    table keep columns( table name[], columns to keep[] );  // Erase all other input data which is not of interest
	}


	define additional procedure( table load csv and keep, table load and keep, { { table name, literal }, { file name,  literal }, { columns to keep, parameters} } );



	// Function:	abbreviate names
	//
	// Description:	Abbreviates a name into initials
	//
	// Parameters:	literal		Full name (First name followed by last name) 
	//
	// Return val:	literal		Name of chosen file.
	//
	// Description:	Takes the first letter of evry word.
	//		Additional letters are included if continuing with:
	//		Ch, Gh, Ll, Ph, Th, Sch, Sh, Sp, St, Zh
	//



    define function(abbreviate name, { { full name, literal } } )
    {
	// Step 1: Split the names

	n[] = {};
	do
	{
	    i[] = find( full name[], " ");
	    if ( i[] == 0 ) // Possibly double space
	    {
		full name[] = right( full name[], -1 );
	    }
	    else: if ( i[] < 0) // no more space (last word)
	    {
		if (full name[]<>"") n[] += { full name[] };
		full name[] = "";
	    }
	    else
	    {
		n[] += { left( full name[], " " ) };
		full name[] = right( full name[], " " );
	    }
	    i[] = find( full name[], " ");
	}
	while (full name[] <> "");
	
	rv[] = "";

	for all parameters( n[], s[] )
	{
	    rv_next[] = "";

	    for all parameters( { Ch, Gh, Ll, Ph, Th, Sch, Sh, Sp, St, Zh }, a[] )
	    {
		if ( find( s[], a[] )==0 )
		{
		    rv_next[] = a[];
		    break;
		}
	    }
	    if (rv_next[]=="") rv_next[] = s[]{0};
	    rv[] += rv_next[];

	}
	return (rv[]);
    }



}

